defmodule Membrane.VideoCompositor.Test.Support.Utils do
  @moduledoc """
  Module with tests functions, that simplify test creation.
  """
  import ExUnit.Assertions

  require Membrane.Logger

  @type input_video_path_t :: binary()
  @type output_video_path_t :: binary()
  @type reference_video_path_t :: binary()
  @type duration_t :: non_neg_integer()
  @type extension_t :: binary()
  @type directory_t :: binary()

  @doc """
  Generate input video file described by the `video_description` and `duration` (in seconds) and save it in the filename autogenerated using video parameters and `extension`.
  Returns filenames for input, reference and output videos.
  """
  @spec prepare_testing_video(
          Membrane.RawVideo.t(),
          duration_t(),
          extension_t(),
          directory_t(),
          directory_t()
        ) ::
          {input_video_path_t(), output_video_path_t(), reference_video_path_t()}
  def prepare_testing_video(
        video_description,
        duration,
        extension,
        tmp_dir \\ "",
        sub_dir_name \\ ""
      ) do
    file_base = get_file_base_name(video_description, duration, extension)

    {input_file_name, out_file_name, ref_file_name} =
      prepare_paths(file_base, tmp_dir, sub_dir_name)

    generate_testing_video(input_file_name, video_description, duration)
    {input_file_name, out_file_name, ref_file_name}
  end

  @doc """
  Create a base filename with `extension` for testing video file, described by `video_description` and `duration` (in seconds).
  """
  @spec get_file_base_name(Membrane.RawVideo.t(), duration_t, extension_t) :: binary()
  def get_file_base_name(video_description, duration, extension) do
    width = video_description.width
    height = video_description.height
    {num, den} = video_description.framerate
    framerate = div(num, den)
    "#{duration}s_#{width}x#{height}_#{framerate}fps.#{extension}"
  end

  @doc """
  Generate video file described by the `video_description` and `duration` (in seconds) and save it in the `file_name`.
  """
  @spec generate_testing_video(input_video_path_t(), Membrane.RawVideo.t(), duration_t()) ::
          nil | :ok
  def generate_testing_video(file_name, video_description, duration) do
    {num, den} = video_description.framerate
    framerate = div(num, den)

    video_description_str = """
    testsrc=\
    duration=#{duration}\
    :size=#{video_description.width}x#{video_description.height}\
    :rate=#{framerate}\
    ,format=yuv420p\
    """

    input = [
      # does not override the output file if it already exists
      "-y",
      # virtual input
      "-f",
      "lavfi",
      # video parameters
      "-i",
      video_description_str
    ]

    output = get_ffmpeg_save_parameters(file_name)

    File.mkdir_p!(Path.dirname(file_name))

    {result, exit_status} =
      System.cmd(
        "ffmpeg",
        input ++ output,
        stderr_to_stdout: true
      )

    if exit_status != 0 do
      raise inspect(result)
    end

    :ok
  end

  @doc """
  Creates the input, output and reference filepaths for the video testing.
  """
  @spec prepare_paths(
          binary(),
          directory_t(),
          directory_t()
        ) ::
          {input_video_path_t(), output_video_path_t(), reference_video_path_t()}
  def prepare_paths(file_base_name, tmp_dir \\ "", sub_dir_name \\ "") do
    videos_dir =
      Path.join([
        File.cwd!(),
        "test",
        "fixtures",
        sub_dir_name
      ])

    tmp_dir = if tmp_dir == "", do: get_tmp_dir(), else: tmp_dir

    in_path = Path.join(videos_dir, "input-#{file_base_name}")
    out_path = Path.join(tmp_dir, "out-#{file_base_name}")
    ref_path = Path.join(tmp_dir, "ref-#{file_base_name}")
    {in_path, out_path, ref_path}
  end

  @doc """
  Generate video file described by the given FFmpeg `filter_description`, using as an input video from `input_path`, and save it in the `reference_path`.
  """
  @spec generate_ffmpeg_reference(input_video_path_t(), reference_video_path_t(), binary) ::
          nil | :ok
  def generate_ffmpeg_reference(input_path, reference_path, filter_description) do
    if String.ends_with?(input_path, ".raw"),
      do: raise("RAW files are not supported (use `generate_raw_ffmpeg_reference` instead)")

    input = [
      # overrides the output file without asking if it already exists
      "-y",
      # video input filename
      "-i",
      input_path,
      # description of the filter (transformation graph)
      "-vf",
      filter_description
    ]

    output = get_ffmpeg_save_parameters(reference_path)

    {result, exit_status} =
      System.cmd(
        "ffmpeg",
        input ++ output,
        stderr_to_stdout: true
      )

    if exit_status != 0 do
      raise inspect(result)
    end
  end

  @doc """
  Generate video file described by the given FFmpeg `filter_description`, using as an input raw video from `input_path` described by `input_video_description`, and save it in the `reference_path`.
  """
  @spec generate_raw_ffmpeg_reference(
          input_video_path_t(),
          Membrane.RawVideo.t(),
          reference_video_path_t(),
          binary
        ) :: nil | :ok
  def generate_raw_ffmpeg_reference(
        input_path,
        input_video_description,
        reference_path,
        filter_description
      ) do
    unless String.ends_with?(input_path, ".raw"), do: raise("Only RAW files are supported")

    raw_input = get_ffmpeg_raw_video_input_options(input_video_description)

    input = [
      # overrides the output file without asking if it already exists
      "-y",
      # video input filename
      "-i",
      input_path,
      # description of the filter (transformation graph)
      "-vf",
      filter_description
    ]

    output = get_ffmpeg_save_parameters(reference_path)

    {result, exit_status} =
      System.cmd(
        "ffmpeg",
        raw_input ++ input ++ output,
        stderr_to_stdout: true
      )

    if exit_status != 0 do
      raise inspect(result)
    end

    :ok
  end

  @spec get_ffmpeg_save_parameters(binary) :: [binary()]
  defp get_ffmpeg_save_parameters(file_name) do
    # enforce raw video format, if needed
    raw_video =
      if(String.ends_with?(file_name, ".raw"),
        do: ["-f", "rawvideo"],
        else: []
      )

    output = [
      # output file name
      file_name
    ]

    raw_video ++ output
  end

  @spec get_ffmpeg_raw_video_input_options(Membrane.RawVideo.t()) :: [binary()]
  defp get_ffmpeg_raw_video_input_options(video_description) do
    remove_prefix = fn full, prefix ->
      base = byte_size(prefix)
      <<_prefix::binary-size(base), rest::binary>> = full
      rest
    end

    {num, den} = video_description.framerate

    [
      "-video_size",
      "#{video_description.width}x#{video_description.height}",
      "-framerate",
      "#{div(num, den)}",
      "-pixel_format",
      "yuv#{video_description.pixel_format |> Atom.to_string() |> remove_prefix.("I")}p",
      "-f",
      "rawvideo"
    ]
  end

  @doc """
  Compare contents of two raw files.
  """
  @spec compare_contents(binary(), binary()) :: true
  def compare_contents(output_path, reference_path) do
    {:ok, reference_file} = File.read(reference_path)
    {:ok, output_file} = File.read(output_path)
    assert output_file == reference_file
  end

  @doc """
  Compare contents of two raw files, succeeding when `different_bytes / length < allowed_error`
  """
  @spec compare_contents_with_error(binary(), binary(), float()) :: boolean()
  def compare_contents_with_error(output_path, reference_path, allowed_error \\ 0.003) do
    {:ok, reference_file} = File.read(reference_path)
    {:ok, output_file} = File.read(output_path)

    assert byte_size(reference_file) == byte_size(output_file)

    errors =
      Enum.zip(:binary.bin_to_list(reference_file), :binary.bin_to_list(output_file))
      |> Enum.count(fn {b1, b2} -> b1 != b2 end)

    assert errors / byte_size(reference_file) < allowed_error
  end

  @doc """
  Get tmp directory of the project.
  """
  @spec get_tmp_dir() :: directory_t()
  def get_tmp_dir() do
    Path.join(File.cwd!(), "tmp")
  end
end
